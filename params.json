{
  "name": "Enjoin ORM",
  "tagline": "Multi dialect ORM for PHP inspired by Sequelize.JS",
  "body": "Enjoin ORM\r\n==========\r\n\r\n## Introduction\r\n\r\nEnjoin is another PHP ORM (Object Relational Mapping) designed for [Laravel 4](http://laravel.com/) framework\r\nand inspired by [Sequelize.js](http://sequelizejs.com/) ORM.\r\nEnjoin uses active-record pattern.\r\n\r\nLaravel has built in ORM, called [Eloquent](http://laravel.com/docs/4.2/eloquent).\r\nUnfortunately, there are some major disadvantages in Eloquent:\r\n\r\n* Unable to construct associations via `join` clause\r\n(see [Unable to Get Eloquent to Automatically Create Joins](http://stackoverflow.com/questions/11099570/unable-to-get-eloquent-to-automatically-create-joins)).\r\n* Unable to built in validation for model.\r\n* Unable to order by eager loaded records. \r\n\r\nEnjoin relies on Laravel components, such as `Database` and `Cache`.\r\n\r\n## Documentation\r\n\r\n* [Installation](#installation)\r\n* [Models](#models)\r\n  * [Definition](#definition)\r\n  * [Data types](#data-types)\r\n  * [Getters and setters](#getters-and-setters)\r\n  * [Validations](#validations)\r\n  * [Data retrieval / Finders](#data-retrieval--finders)\r\n    * [find](#find)\r\n    * [findOrCreate](#findorcreate)\r\n    * [findAndCountAll](#findandcountall)\r\n    * [findAll](#findall)\r\n    * [Complex filtering / OR queries](#complex-filtering--or-queries)\r\n    * [Manipulating the dataset with limit, offset, order and group](#manipulating-the-dataset-with-limit-offset-order-and-group)\r\n    * [Raw queries](#raw-queries)\r\n    * [*TODO count*](#count)\r\n    * [*TODO max*](#max)\r\n    * [*TODO min*](#min)\r\n    * [*TODO sum*](#sum)\r\n  * [Eager loading](#eager-loading)\r\n  * [Ordering Eager Loaded Associations](#ordering-eager-loaded-associations)\r\n  * [Nested eager loading](#nested-eager-loading)\r\n\r\n## Installation\r\n\r\n### Warning\r\n\r\nDo not use this package in production because it still in heavy development phase.  \r\n\r\n### Requirements\r\n\r\n* PHP 5.4+\r\n* Laravel 5.0+\r\n\r\n### Via composer\r\n\r\nAdd `mightydes\\enjoin` as a requirement to composer.json:\r\n```json\r\n{\r\n    \"require\": {\r\n        \"mightydes/enjoin\": \"dev-master@dev\"\r\n    }\r\n}\r\n```\r\n\r\nBy default, all models files should be in `Models` namespace.\r\nYou can change it in `app/Providers/ConfigServiceProvider.php`:\r\n```php\r\n    public function register()\r\n    {\r\n        config([\r\n            'enjoin' => [\r\n                'models_namespace' => 'App\\Models'\r\n            ]\r\n        ]);\r\n    }\r\n```\r\n\r\nUpdate your packages with `composer update` or install with `composer install`.\r\n\r\nOnce Composer has installed or updated your packages you need to register Enjoin with Laravel itself.\r\nOpen up `app/config/app.php` and find the providers key towards the bottom and add:\r\n```php\r\n'Enjoin\\EnjoinServiceProvider'\r\n```\r\n\r\nThen add Enjoin Facade for easier access:\r\n```php\r\n'Enjoin' => 'Enjoin\\EnjoinFacade'\r\n```\r\n\r\nNow you can access Enjoin in global namespace or in other namespace by adding:\r\n```php\r\nuse Enjoin;\r\n```\r\n\r\n## Models\r\n\r\n### Definition\r\n\r\nFirst of all, create `BaseModel.php` in `app/models` directory:\r\n\r\n```php\r\n<?php\r\n// app/models/BaseModel.php\r\n\r\nnamespace Models;\r\n\r\nabstract class BaseModel\r\n{\r\n\r\n    // Connection name from `app/config/database` section.\r\n    // You can use `default` string.\r\n    public $connection;\r\n\r\n    // Related table name.\r\n    // You may pass this variable, and engine fills it automatically.\r\n    public $table;\r\n\r\n    public $timestamps = true;\r\n\r\n    // Name for `createdAt` field (`created_at` by default).\r\n    public $createdAt;\r\n\r\n    // Name for `updatedAt` field (`updated_at` by default).\r\n    public $updatedAt;\r\n\r\n    public $cache = false;\r\n\r\n    /**\r\n     * @return array\r\n     */\r\n    public function getAttributes()\r\n    {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * @return array\r\n     */\r\n    public function getRelations()\r\n    {\r\n        return [];\r\n    }\r\n\r\n} // end of class\r\n```\r\n\r\nEach Enjoin model should be placed in `app/models` folder and extends `BaseModel` class.\r\n\r\n```php\r\n<?php\r\n// app/models/Project.php\r\n\r\nnamespace Models;\r\n\r\nuse Enjoin;\r\n\r\nclass Project extends BaseModel\r\n{\r\n\r\n    public function getAttributes()\r\n    {\r\n        return [\r\n            'id' => ['type' => Enjoin::Integer()],\r\n            'title' => ['type' => Enjoin::String()],\r\n            'description' => ['type' => Enjoin::Text()]\r\n         ];\r\n    }\r\n\r\n} // end of class\r\n```\r\n\r\nYou can place model file in sub-folder, in this case you can access model like this:\r\n\r\n```php\r\n// app/models/alpha/Users.php\r\nEnjoin::get('alpha.Users');\r\n```\r\n\r\n### Data types\r\n\r\nEnjoin currently supports the following data types:\r\n\r\n```php\r\nEnjoin.Integer();   // --> INTEGER\r\nEnjoin.Boolean();   // --> TINYINT(1) (1 or null)\r\nEnjoin.String();    // --> VARCHAR\r\nEnjoin.Text();      // --> TEXT\r\nEnjoin.Float();     // --> FLOAT\r\nEnjoin.Date();      // -->DATETIME\r\nEnjoin.Enum();      // --> ENUM\r\n```\r\n\r\n### Getters and setters\r\n\r\nIt is possible to define 'object-property' getters and setters functions on your models,\r\nthese can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.\r\n\r\nTo define getter or setter, add `get` or `set` closure to model field:\r\n\r\n```php\r\npublic function getAttributes()\r\n{\r\n    return [\r\n    \r\n        'latlong' => [\r\n            'type' => Enjoin::String(),\r\n            'allowNull' => false,\r\n            'get' => function ($attr, $getValue) {\r\n                    $latlong = $getValue($attr);\r\n                    if (is_string($latlong) && strlen($latlong) > 0) {\r\n                        $latlong = explode(',', $latlong);\r\n                        if (count($latlong) === 2) {\r\n                            return array_map('floatval', $latlong);\r\n                        }\r\n                    }\r\n                    return null;\r\n                },\r\n            'set' => function ($attr, $getValue) {\r\n                    $latlong = $getValue($attr);\r\n                    if (is_array($latlong)) {\r\n                        return implode(',', $latlong);\r\n                    }\r\n                    return $latlong;\r\n                }\r\n        ],\r\n\r\n    ];\r\n}\r\n```\r\n\r\nGetter (setter) closure has string `$attr` parameter (table column name),\r\nand closure `$getValue` parameter, which returns value for given attribute.\r\n\r\n### Validations\r\n\r\nYou can specify validation on model field.\r\nValidation will be called when executing the `build()` or `create()` functions.\r\nFor example:\r\n\r\n```php\r\npublic function getAttributes()\r\n{\r\n    return [\r\n    \r\n        'name' => [\r\n            'type' => Enjoin::String(),\r\n            'allowNull' => false,\r\n            'validate' => 'between:1,255'\r\n        ],\r\n\r\n    ];\r\n}\r\n```\r\n\r\nOn validation fail error would be dropped.\r\nFor mor information about available methods and notations\r\nlook at corresponded [Laravel section](http://laravel.com/docs/4.2/validation#available-validation-rules).\r\n\r\n### Data retrieval / Finders\r\n\r\nFinder methods are designed to get data from the database.\r\nThe returned data is an active record object.\r\nTake a look at available model finders:\r\n\r\n#### find\r\n\r\nSearch for one specific element in the database:\r\n\r\n```php\r\n\r\n// search for known ids\r\n$project = Enjoin::get('Project')->find(123);\r\n// $project will be an instance of Record and stores the content of the table entry\r\n// with id 123. if such an entry is not defined you will get null\r\n \r\n// search for attributes\r\n$project = Enjoin::get('Project')->find([\r\n    'where' => ['title' => 'aProject']\r\n]);\r\n// $project will be the first entry of the Projects table with the title 'aProject' || null\r\n \r\n// select some attributes\r\n$project = Enjoin::get('Project')->find([\r\n    'where' => ['title' => 'aProject'],\r\n    'attributes' => ['id', 'name']\r\n]);\r\n// $project will be the first entry of the Projects table with the title 'aProject' || null\r\n// picked only 'id' and 'name' columns\r\n\r\n```\r\n\r\n*TODO: attribute renaming*\r\n\r\n#### findOrCreate\r\n\r\nSearch for a specific element or create it if not available.\r\nThe method `findOrCreate` can be used to check if a certain element is already existing in the database.\r\nIf that is the case the method will result in a respective instance.\r\nIf the element does not yet exist, it will be created.\r\n\r\nLet's assume we have an empty database with a `User` model which has a `username` and a `job`:\r\n\r\n```php\r\n$user = Enjoin::get('User')\r\n    ->findOrCreate([ 'username' => 'Bob', 'job' => 'Technical Lead JavaScript' ]);\r\n```\r\n\r\nThe code created a new instance.\r\n\r\nSo when we already have an instance,\r\n\r\n```php\r\nEnjoin::get('User')->create([ 'username' => 'Alice', 'job' => 'Ultramarine' ]);\r\n$user = Enjoin::get('User')\r\n    ->findOrCreate([ 'username' => 'Alice', 'job' => 'Ultramarine' ]);\r\n```\r\n\r\nthe existing entry will not be changed. See the `job` of the second user, and the fact that created was false.\r\n\r\n#### findAndCountAll\r\n\r\nSearch for multiple elements in the database, returns both data and total count.\r\n\r\nThis is a convenience method that combines `findAll()` and `count()` (see below),\r\nthis is useful when dealing with queries related to pagination where you want to retrieve data\r\nwith a `limit` and `offset` but also need to know the total number of records that match the query.\r\n\r\nThe success handler will always receive an object with two properties:\r\n\r\n* `count` - an integer, total number records (matching the where clause).\r\n* `rows` - an array of objects, the records (matching the where clause) within the limit/offset range.\r\n\r\n```php\r\n$r = Enjoin::get('Project')->findAndCountAll([\r\n    'where' => [ 'title' => ['like' => '%foo%'] ],\r\n    'offset' => 10,\r\n    'limit' => 2\r\n]);\r\n```\r\nThe options list that you pass to `findAndCountAll()` is the same as for `findAll()` (described below).\r\n\r\n#### findAll\r\n\r\nSearch for multiple elements in the database:\r\n\r\n```php\r\n// find multiple entries\r\n$projects = Enjoin::get('Project')->findAll();\r\n// $projects will be an array of all Project instances\r\n\r\n// search for specific attributes - hash usage\r\n$projects = Enjoin::get('Project')->findAll([ 'where' => [ 'name' => 'A Project' ] ]);\r\n// $projects will be an array of Project instances with the specified name\r\n\r\n// search within a specific range\r\n$projects = Enjoin::get('Project')->findAll([ 'where' => ['id' => [1, 2, 3]] ]);\r\n// projects will be an array of Projects having the id 1, 2 or 3\r\n// this is actually doing an `IN` query\r\n\r\n$projects = Enjoin::get('Project')->findAll([\r\n    'where' => [\r\n        'id' => [\r\n            'gt' => 6,              // id > 6\r\n            'gte' => 6,             // id >= 6\r\n            'lt' => 10,             // id < 10\r\n            'lte' => 10,            // id <= 10\r\n            'ne' => 20,             // id != 20\r\n            'between' => [6, 10],   // BETWEEN 6 AND 10\r\n            'nbetween' => [6, 10],  // NOT BETWEEN 11 AND 15\r\n            'like' => '%1%',        // LIKE '%1%'\r\n        ]\r\n    ]\r\n]);\r\n```\r\n\r\n*TODO: between, nbetween*\r\n\r\n#### Complex filtering / OR queries\r\n\r\nIt is possible to do complex where queries with multiple levels of nested `AND` and `OR` conditions.\r\nIn order to do that you can use `Enjoin::sqlOr` and `Enjoin::sqlAnd` and pass an arbitrary amount of arguments to it.\r\nEvery argument will get transformed into a proper SQL condition and gets joined with the either `AND` or `OR`.\r\n\r\n```php\r\nEnjoin::get('Project')->find([\r\n    'where' => Enjoin::sqlAnd(\r\n        ['name' => 'a project'],\r\n        Enjoin::sqlOr(\r\n            ['id' => [1, 2, 3]],\r\n            ['id' => ['lt' => 10]]\r\n        )\r\n    )\r\n]);\r\n```\r\n\r\nThis code will generate the following query:\r\n\r\n```sql\r\nSELECT *\r\nFROM `Projects`\r\nWHERE (\r\n  `Projects`.`name`='a project'\r\n   AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` < 10)\r\n)\r\nLIMIT 1;\r\n```\r\n\r\nNotice, that instead of `Enjoin::sqlAnd` you can also use a plain array which will be treated as `Enjoin::sqlAnd`\r\nif it contains objects or hashes or other complex data types.\r\n\r\n#### Manipulating the dataset with limit, offset, order and group\r\n\r\nTo get more relevant data, you can use limit, offset, order and grouping:\r\n\r\n```php\r\n// limit the results of the query\r\nEnjoin::get('Project')->findAll([ 'limit' => 10 ]);\r\n\r\n// step over the first 10 elements\r\nEnjoin::get('Project')->findAll([ 'offset' => 10 ]);\r\n\r\n// step over the first 10 elements, and take 2\r\nEnjoin::get('Project')->findAll([ 'offset' => 10, 'limit' => 2 ]);\r\n```\r\n\r\nThe syntax for grouping and ordering are equal, so below it is only explained with a single example for group,\r\nand the rest for order. Everything you see below can also be done for group:\r\n\r\n```php\r\nEnjoin::get('Project')->findAll([ 'order' => 'title DESC' ]);\r\n// yields ORDER BY title DESC\r\n \r\nEnjoin::get('Project')->findAll([ 'group' => 'name' ]);\r\n// yields GROUP BY name\r\n```\r\n\r\nNotice how in the two examples above, the string provided is inserted verbatim into the query,\r\ni.e. column names are not escaped. If you want to escape column names, you should provide an array of arguments,\r\neven though you only want to order / group by a single column:\r\n\r\n```php\r\nEnjoin::get('Foo')->find([\r\n    'order' => [\r\n        'name',\r\n        // will return `name`\r\n        \r\n        'username DESC',\r\n        // will return `username DESC` -- i.e. don't do it!\r\n        \r\n        ['username', 'DESC'],\r\n        // will return `username` DESC\r\n    ]\r\n]);\r\n```\r\n\r\n*TODO: aggregate methods*\r\n\r\n#### Raw queries\r\n\r\nSupported by Laravel Database component, [see](http://laravel.com/docs/4.2/database).\r\n\r\n#### count\r\n\r\n*TODO: Count the occurrences of elements in the database*\r\n\r\n#### max\r\n\r\n*TODO: Get the greatest value of a specific attribute within a specific table*\r\n\r\n#### min\r\n\r\n*TODO: Get the least value of a specific attribute within a specific table*\r\n\r\n#### sum\r\n\r\n*TODO: Sum the value of specific attributes*\r\n\r\n### Eager loading\r\n\r\nWhen you are retrieving data from the database there is a fair chance that you also want to get their associations.\r\nThis is possible and is called eager loading. The basic idea behind that, is the use of the attribute\r\n`include` when you are calling `find` or `findAll`. Lets assume the following setup:\r\n\r\n```php\r\n// app/models/Task.php\r\n\r\npublic function getRelations()\r\n{\r\n    return [\r\n        Enjoin::belongsTo(Enjoin::get('User'))\r\n    ];\r\n}\r\n\r\n\r\n// app/models/User.php\r\n\r\npublic function getRelations()\r\n{\r\n    return [\r\n        Enjoin::hasMany(Enjoin::get('Task')),\r\n        Enjoin::hasMany(Enjoin::get('Tool'), ['as' => 'Instruments'])\r\n    ];\r\n}\r\n```\r\n\r\nOK. So, first of all, let's load all tasks with their associated user:\r\n\r\n```php\r\n$r = Enjoin::get('Task')->findAll([ 'include' => Enjoin::get('User') ]);\r\n\r\n/*\r\n[{\r\n    \"name\": \"A Task\",\r\n    \"id\": 1,\r\n    \"createdAt\": \"2013-03-20T20:31:40.000Z\",\r\n    \"updatedAt\": \"2013-03-20T20:31:40.000Z\",\r\n    \"UserId\": 1,\r\n    \"user\": {\r\n        \"name\": \"John Doe\",\r\n        \"id\": 1,\r\n        \"createdAt\": \"2013-03-20T20:31:45.000Z\",\r\n        \"updatedAt\": \"2013-03-20T20:31:45.000Z\"\r\n    }\r\n}]\r\n*/\r\n```\r\n\r\nNotice that the accessor of the associated data is the name of the model in camel-case with lower-cased first character.\r\nAlso the accessor is singular as the association is one-to-something.\r\n\r\nNext thing: Loading of data with many-to-something associations:\r\n\r\n```php\r\n$r = Enjoin::get('User')->findAll([ 'include' => Enjoin::get('Task') ]);\r\n\r\n/*\r\n[{\r\n    \"name\": \"John Doe\",\r\n    \"id\": 1,\r\n    \"createdAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"tasks\": [{\r\n        \"name\": \"A Task\",\r\n        \"id\": 1,\r\n        \"createdAt\": \"2013-03-20T20:31:40.000Z\",\r\n        \"updatedAt\": \"2013-03-20T20:31:40.000Z\",\r\n        \"UserId\": 1\r\n    }]\r\n}]\r\n*/\r\n```\r\n\r\nNotice that the accessor is plural. This is because the association is many-to-something.\r\n\r\nIf an association is aliased (using the `as` option), you **must** specify this alias when including the model.\r\nNotice how the user's `Tool`s are aliased as `Instruments` above.\r\nIn order to get that right you have to specify the model you want to load, as well as the alias:\r\n\r\n```php\r\n$r = Enjoin::get('User')\r\n    ->findAll([ 'include' => ['model' => Enjoin::get('Tool'), 'as' => 'Instruments'] ]);\r\n\r\n/*\r\n[{\r\n    \"name\": \"John Doe\",\r\n    \"id\": 1,\r\n    \"createdAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"instruments\": [{\r\n        \"name\": \"Toothpick\",\r\n        \"id\": 1,\r\n        \"createdAt\": null,\r\n        \"updatedAt\": null,\r\n        \"UserId\": 1\r\n    }]\r\n}]\r\n*/\r\n```\r\n\r\n### Ordering Eager Loaded Associations\r\n\r\nIn the case of a one-to-many relationship:\r\n\r\n```php\r\nEnjoin::get('Company')->findAll([\r\n    'include' => Enjoin::get('Division'),\r\n    'order' => [ Enjoin::get('Division'), 'name' ]\r\n]);\r\nEnjoin::get('Company')->findAll([\r\n    'include' => Enjoin::get('Division'),\r\n    'order' => [ Enjoin::get('Division'), ['name', 'DESC'] ]\r\n]);\r\nEnjoin::get('Company')->findAll([\r\n    'include' => [ ['model' => Enjoin::get('Division'), 'as' => 'Div'] ],\r\n    'order' => [ ['model' => Enjoin::get('Division'), 'as' => 'Div'], 'name' ]\r\n]);\r\nEnjoin::get('Company')->findAll([\r\n    'include' => [ ['model' => Enjoin::get('Division'), 'include' => Enjoin::get('Department')] ],\r\n    'order' => [ Enjoin::get('Division'), Enjoin::get('Department'), 'name' ]\r\n]);\r\n```\r\n\r\n*TODO: sort by attributes in the `through` table*\r\n\r\n### Nested eager loading\r\n\r\n```php\r\n$r = Enjoin::get('User')->findAll([\r\n    'include' => [\r\n        ['model' => Enjoin::get('Tool'), 'as' => 'Instruments', 'include' => [\r\n            ['model' => Enjoin::get('Teacher'), 'include' => [\r\n                /* etc */\r\n            ]]\r\n        ]]\r\n    ]\r\n]);\r\n\r\n/*\r\n[{\r\n    \"name\": \"John Doe\",\r\n    \"id\": 1,\r\n    \"createdAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"updatedAt\": \"2013-03-20T20:31:45.000Z\",\r\n    \"instruments\": [{ // 1:M and N:M association\r\n        \"name\": \"Toothpick\",\r\n        \"id\": 1,\r\n        \"createdAt\": null,\r\n        \"updatedAt\": null,\r\n        \"UserId\": 1,\r\n        \"Teacher\": { // 1:1 association\r\n            \"name\": \"Jimi Hendrix\"\r\n        }\r\n    }]\r\n}]\r\n*/\r\n```\r\n\r\n**Final note**: If you include an object which is not associated, Enjoin will throw an error.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}